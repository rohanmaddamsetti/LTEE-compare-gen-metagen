//SLiM for STIMS 01/10/2022
//Wright-fisher model for the SliMulation of haploid genomes
//Nkrumah Grant and Rohan Maddamsetti

initialize()

{
	initializeSLiMOptions(mutationRuns=1);
	setSeed(737);
	defineConstant("Ne", 1e7); //effective population size
	defineConstant("Mu", 1e-8); // Nonmutator ~ 1e-10;
	//  Hypermutator ~ 1e-8(100x)
	
	defineConstant("genomeSize", 1e6);
	defineConstant("N_generations", 10000);
	
	defineConstant("Mu_rescale_factor", 1); // Mu rescaling off
	initializeMutationRate(Mu_rescale_factor*Mu);
	
	//Define LTEE parameters before scaling
	//Genome size = 4.62e6 base pairs
	//Ne = 3.3e7 cells
	//initial sb in LTEE = 0.01587 (Izutzu et al. 2021)
	// mu = 8.9e-11 per base-pair per cell per generation,
	// so mu = 0.00041118 = 4.11e-4 per cell per generation
	
	// parameters in STEPS simulations (Izutzu et al. 2021):
	//all of the simulations in this study used the following inputs:
	 // final population size, Nf = 5 x 10^8 cells;
	 //beneficial mutation rate, mu_B = 1.7 x 10^â€“6 per cell per generation
	 // mean effect size of beneficial mutations in the ancestor,
	 // s = 0.01587;
	 // and strength of diminishing-returns epistasis, g = 6.0217.	
		
	initializeMutationType("m1", 1.0, "e", 0.01); //beneficial
	//initializeMutationType("m2", 1.0, "e", -0.01); // deleterious
	initializeMutationType("m2", 1.0, "f", -0.3); // strongly deleterious
	
	// completely neutral:
	initializeMutationType("m3", 1.0, "f", 0.0);	
	
	// nearly-neutral: use -1*Beta(alpha=0.0074,beta=2.4),
	// based on Lydia Robert et al. (2018) in Science.
	// multiply by -1 since most mutations are weakly deleterious.
	initializeMutationType("m4", 1.0, "s", "return -1*rbeta(1,0.0074,2.4);");


	
	m1.color = "green";
	m2.color = "red";
	m3.color = "yellow";
	m4.color = "orange";
	
	m1.colorSubstitution = "green";
	m2.colorSubstitution = "red";
	m3.colorSubstitution = "yellow";
	m4.colorSubstitution = "orange";
	
	
	//Here, I parameterize the distribution of fitness effects in each of the genomic modules for each of the mutation types parameterized above.
	
	initializeGenomicElementType("g1", c(m1,m2), c(0.1, 0.9)); // 10% beneficial, 90% deleterious since these genes are super important.
	initializeGenomicElementType("g2", c(m2,m4), c(0.4, 0.6)); // 40% strong deleterious
	initializeGenomicElementType("g3", m3, 1.0);	// 100% neutral.
	initializeGenomicElementType("g4", m4, 1.0);	// weakly deleterious background.
	
	g1.color = "green";
	g2.color = "red";
	g3.color = "yellow";
	g4.color = "orange";
	
	initializeGenomicElement(g1, 0,24999);
	initializeGenomicElement(g2, 25000,49999);
	initializeGenomicElement(g3, 50000, 74999);
	initializeGenomicElement(g4, 75000, 999999);
	initializeRecombinationRate(0); // In SLiM recombination is between sister chromatids
}


// At the first generation:
// - create a subpopulation (or many)
1 early ()
{
	sim.chromosome.colorSubstitution = ""; //keeps the color I defined for mutation events above in the initialize callback.
	
	sim.addSubpop("p1", asInteger(Ne));
	p1.setCloningRate(1.0); // Essential for bacteria.	
}

//Remove mutations from second chromosome
modifyChild()
{
	if (size(childGenome2.mutations))		
		childGenome2.removeMutations();
	return T;
}

// At each generation:
// - Remove fixed mutations
late()
{
	// print the generation that we are on.
	cat("Generation: "  + sim.generation + "\n");

	// Remove fixed mutations
	// (SLiM does it automatically for diploid,
	// but for haploid, mutations are fixed at 0.5)
	//This must be done for each mutation class.
	
	muts_m1 = sim.mutationsOfType(m1);
	m1freqs = sim.mutationFrequencies(NULL, muts_m1);
	fixed_muts_m1 = muts_m1[m1freqs == 0.5];
	
	if (size(fixed_muts_m1) > 0)
		sim.subpopulations.genomes.removeMutations(fixed_muts_m1, T);
	
	muts_m2 = sim.mutationsOfType(m2);
	m2freqs = sim.mutationFrequencies(NULL, muts_m2);
	fixed_muts_m2 = muts_m2[m2freqs == 0.5];
	
	if (size(fixed_muts_m2) > 0)
		sim.subpopulations.genomes.removeMutations(fixed_muts_m2, T);
	
	muts_m3 = sim.mutationsOfType(m3);
	m3freqs = sim.mutationFrequencies(NULL, muts_m3);
	fixed_muts_m3 = muts_m3[m3freqs == 0.5];
	
	if (size(fixed_muts_m3) > 0)
		sim.subpopulations.genomes.removeMutations(fixed_muts_m3, T);
	
	muts_m4 = sim.mutationsOfType(m4);
	m4freqs = sim.mutationFrequencies(NULL, muts_m4);
	fixed_muts_m4 = muts_m4[m4freqs == 0.5];	
	
	if (size(fixed_muts_m4) > 0)
		sim.subpopulations.genomes.removeMutations(fixed_muts_m4, T);

}

//Output showing which mutations are segregating in the population at 100 generation intervals.
//Change these file names for the Nonmutator and Hypermutator scenarios.
1:10000 late ()
{
	if (sim.generation % 100 == 0)
	{
		sim.outputMutations(sim.mutationsOfType(m1), "SLiM-output.txt", append = T);
		sim.outputMutations(sim.mutationsOfType(m2), "SLiM-output.txt", append = T);
		sim.outputMutations(sim.mutationsOfType(m3), "SLiM-output.txt", append = T);
		sim.outputMutations(sim.mutationsOfType(m4), "SLiM-output.txt", append = T);	
	}
}