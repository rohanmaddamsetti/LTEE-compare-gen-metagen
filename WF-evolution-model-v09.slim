//SLiM for STIMS 01/06/2022
//Wright-fisher model for the SliMulation of haploid genomes
//Nkrumah Grant

initialize()

{
	
	initializeSLiMOptions(mutationRuns=1);
	setSeed(737);
	defineConstant("Ne", 5e5); //effective population size
	defineConstant("Mu", 2.225e-9); // Nonmutator = 8.9e-11; Hypermutator = 8.9e-10 (10x), 8.9e-9(100x)
	//currently set at 1/4 the size of the 100 x mutator population to account for a genome size that is
	//1/4th smaller being modeled here.
	
	defineConstant("genomeSize", 1e6);
	defineConstant("N_generations", 10000);
	initializeMutationRate(Mu);
	
	//Define LTEE parameters before scaling
	//Genome size = 4.62e6
	//Ne = 3.3e7
	//sb = 0.01587 (Izutzu et al. 2021)
	//Neutral mu = 8.9e-11
	
	//Rescaled LTEE parameters for computational efficiency
	//Simulating genome size that is approximately 1/4 the size of REL606 ... 1e6
	//Let's also rescale all other parameters by this much to begin with.
	//Ne = 3.3e7/4 = 8.25e6
	//Neutral mu = 8.9e-11/4 = 2.225e-11
	
	initializeMutationType("m1", 1.0, "f", 0.01); //neutral mutation
	initializeMutationType("m2", 1.0, "g", 0.01587, 2); //beneficial mutation
	initializeMutationType("m3", 1.0, "g", -0.03, 0.2); //deleterious mutation
	
	//initializeMutationType("m4", 1.0, "f", 0.000002); //weakly beneficial synonymous mutation
	
	m1.color = "yellow";
	m2.color = "green";
	m3.color = "red";
	//m4.color = "blue";
	
	m1.colorSubstitution = "grey";
	m2.colorSubstitution = "green";
	m3.colorSubstitution = "red";
	//m4.colorSubstitution = "blue";
	
	//Here, I parameterize the distribution of fitness effects in each of the genomic modules for each of the mutation types parameterized above.
	
	//initializeGenomicElementType("g1", c(m1,m4), c(0.5,0.5)); //neutral and weak synonymous
	
	initializeGenomicElementType("g1", c(m1), c(1)); //neutral
	
	initializeGenomicElementType("g2", c(m1,m2), c(0.05,0.5)); // weak selection
	
	initializeGenomicElementType("g3", c(m1,m2), c(0.05,1.0)); // strong selection
	
	initializeGenomicElementType("g4", c(m1,m3), c(0.05,1)); // purifying selection
	
	// Will turn each one of these on when necessary. Should drive mutation dynamics for each region such that for the hyper mutator case there the obs mutations lie in the middle of the null distribution.
	
	initializeGenomicElementType("g5", c(m1), c(1)); // weighted neutral module
	
	//initializeGenomicElementType("g5", c(m1), c(1)); // weighted weak positive module
	
	//initializeGenomicElementType("g5", c(m1), c(1)); // weighted positive module
	
	//initializeGenomicElementType("g5", c(m1), c(1)); // weighted purifing module
	
	
	
	g1.color = "yellow";
	
	g2.color = "blue";
	
	g3.color = "green";
	
	g4.color = "red";
	
	g5.color = "yellow";
	
	initializeGenomicElement(g1, 0,100000);
	
	initializeGenomicElement(g2, 100001,200001);
	
	initializeGenomicElement(g3,200002,300002);
	
	initializeGenomicElement(g4, 300003,400003);
	
	initializeGenomicElement(g5, 400004, 1000004);
	
	initializeRecombinationRate(0); // In SLiM recombination is between sister chromatids

}



// At the first generation:

// - create a subpopulation (or many)



1 early ()

{
	
	sim.chromosome.colorSubstitution = ""; //keeps the color I defined for mutation events above in the initialize callback.
	
	sim.addSubpop("p1", asInteger(Ne));
	
	p1.setCloningRate(1.0); // Essential for bacteria.
	
	sim.rescheduleScriptBlock(s1, start=N_generations, end=N_generations);

}



fitness(m3)

{
	
	// convert fecundity-based selection to survival-based selection
	
	if (runif(1) < relFitness)
		
		return 1.0;
	
	else
		
		return 0.0;

}



//Remove mutations from second chromosome

modifyChild()

{
	
	if (size(childGenome2.mutations))
		
		childGenome2.removeMutations();
	
	return T;

}



// At each generation:

// - Remove fixed mutations

late()

{
	
	// Remove fixed mutation
	
	// (SLiM does it automatically for diploid,
	
	// but for haploid, mutations are fixed at 0.5)
	
	//This must be done for each mutation class (m1-m3 in this model).
	
	muts_m1 = sim.mutationsOfType(m1);
	
	freqs = sim.mutationFrequencies(NULL, muts_m1);
	
	fixed_muts_m1 = muts_m1[freqs == 0.5];
	
	if (size(fixed_muts_m1) > 0)
		
		sim.subpopulations.genomes.removeMutations(fixed_muts_m1, T);
	
	muts_m2 = sim.mutationsOfType(m2);
	
	freqs = sim.mutationFrequencies(NULL, muts_m2);
	
	fixed_muts_m2 = muts_m2[freqs == 0.5];
	
	if (size(fixed_muts_m2) > 0)
		
		sim.subpopulations.genomes.removeMutations(fixed_muts_m2, T);
	
	muts_m3 = sim.mutationsOfType(m3);
	
	freqs = sim.mutationFrequencies(NULL, muts_m3);
	
	fixed_muts_m3 = muts_m3[freqs == 0.5];
	
	if (size(fixed_muts_m3) > 0)
		
		sim.subpopulations.genomes.removeMutations(fixed_muts_m3, F); // see pg 254 on removing fixed mutations '
	
	
	
	//muts_m4 = sim.mutationsOfType(m4);
	
	//freqs = sim.mutationFrequencies(NULL, muts_m4);
	
	//fixed_muts_m4 = muts_m4[freqs == 0.5];
	
	//if (size(fixed_muts_m4) > 0)
	
	//sim.subpopulations.genomes.removeMutations(fixed_muts_m4, T);

}



//Output showing which mutations are segregating and fixing in the population at 100 generation intervals.

//I change these file names for the Nonmutator and Hypermutator scenarios.



1:10000 late ()

{
	
	if (sim.generation % 500 == 0)
	
	{
		
		sim.outputMutations(sim.mutationsOfType(m1), "~/Desktop/20220107-new-par.txt", append = T);
		
		sim.outputMutations(sim.mutationsOfType(m2), "~/Desktop/20220107-new-par.txt", append = T);
		
		sim.outputMutations(sim.mutationsOfType(m3), "~/Desktop/20220107-new-par.txt", append = T);
	
	}

}



// End simulation

//Prints mutations that were fixed in the population at the end of the run.

//Change file names for Nonmutator and Hypermutator case.

s1 10000 late ()

{
	
	sim.outputFixedMutations("~/Desktop/20220106-new-par7-fixed", append = T);

}